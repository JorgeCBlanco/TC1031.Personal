"""
Tarea: Implementación de DIJKSTRA
Autores: Jorge Cardenas Blanco, Juan Carlos Arevalo Gomez, Juan Pablo Hernandez Lopez, Luis Fernando Kunze
ENLACE AL VIDEO DE YT:
UF: Estructura de Datos y Algoritmos fundamentales.
*Le extrañaré profe :c -george*
"""


import time
import os
import heapq
import networkx as nx
import matplotlib.pyplot as plt

class Graph:
    def __init__(self, names):
        self.n = len(names)
        self.names = names
        self.adj = {i: [] for i in range(self.n)}
        self.dist = [float('inf')] * self.n
        self.parent = [-1] * self.n
        self.G = nx.Graph()
        for i, name in enumerate(names):
            self.G.add_node(i, label=name)

        self.pos = {
            8: (1.5, 3.1),
            0: (3.5, 3),
            3: (0, 2),
            2: (1.5, 2),
            1: (3.5, 2),
            4: (0, 1),
            5: (3.5, 1),
            6: (-0.8, 1),
            7: (-0.3, -0.2)
        }

        plt.ion()
        self.fig, self.ax = plt.subplots(figsize=(10, 8))

    def add_edge(self, u, v, w):
        self.adj[u].append((v, w))
        self.adj[v].append((u, w))
        self.G.add_edge(u, v, weight=w)

    def print_graph(self):
        print("\nGrafo (lista de adyacencia):\n")
        for u in range(self.n):
            print(f"{u} - {self.names[u]}")
            for v, w in self.adj[u]:
                print(f"   -> {v} - {self.names[v]} [{w} m]")
            print()

    def draw(self, visited=None, current=None, path_edges=None, title_extra=""):
        if visited is None:
            visited = [False] * self.n
        if path_edges is None:
            path_edges = []

        self.ax.clear()

        node_colors = []
        for i in range(self.n):
            if current is not None and i == current:
                node_colors.append("red")
            elif visited[i]:
                node_colors.append("lightgreen")
            else:
                node_colors.append("lightgray")

        edge_colors = []
        edge_widths = []
        for u, v in self.G.edges():
            if (u, v) in path_edges or (v, u) in path_edges:
                edge_colors.append("blue")
                edge_widths.append(3)
            else:
                edge_colors.append("gray")
                edge_widths.append(1)

        labels = {i: str(i) for i in range(self.n)}

        nx.draw(
            self.G,
            pos=self.pos,
            ax=self.ax,
            with_labels=True,
            labels=labels,
            node_color=node_colors,
            edge_color=edge_colors,
            width=edge_widths,
            node_size=1000,
            font_size=12,
            font_weight='bold'
        )

        edge_labels = nx.get_edge_attributes(self.G, "weight")
        edge_labels = {(u, v): f"{w}m" for (u, v), w in edge_labels.items()}
        nx.draw_networkx_edge_labels(self.G, self.pos, edge_labels=edge_labels, ax=self.ax, font_size=9)

        self.ax.set_title("Grafo de Guadalajara " + title_extra, fontsize=14)
        self.ax.axis("off")
        self.fig.canvas.draw()
        plt.pause(0.01)

    def dijkstra(self, start):
        self.dist = [float('inf')] * self.n
        self.parent = [-1] * self.n
        self.dist[start] = 0

        pq = [(0, start)]
        visited = [False] * self.n

        self.draw(visited=visited, current=start, title_extra=f"(inicio en {self.names[start]})")

        while pq:
            d, u = heapq.heappop(pq)
            if visited[u]:
                continue
            visited[u] = True

            os.system("cls" if os.name == "nt" else "clear")
            print(f"Dijkstra desde: {self.names[start]}\n")
            print(f"Nodo actual: {u} - {self.names[u]}\n")

            print("Distancias actuales:")
            for i in range(self.n):
                val = "INF" if self.dist[i] == float('inf') else f"{self.dist[i]} m"
                mark = " [visitado]" if visited[i] else ""
                print(f" {i} - {self.names[i]}: {val}{mark}")
            print()

            for v, w in self.adj[u]:
                if self.dist[u] + w < self.dist[v]:
                    self.dist[v] = self.dist[u] + w
                    self.parent[v] = u
                    heapq.heappush(pq, (self.dist[v], v))

            self.draw(visited=visited, current=u, title_extra=f"(visitando {self.names[u]})")
            time.sleep(0.8)

        print("\nDistancias finales:")
        for i in range(self.n):
            val = "no alcanzable" if self.dist[i] == float('inf') else f"{self.dist[i]} m"
            print(f" - {self.names[i]}: {val}")
        print()

        self.draw(visited=visited, current=None, title_extra=f"(terminado desde {self.names[start]})")

    def print_shortest_path(self, dest):
        if self.dist[dest] == float('inf'):
            print("No hay camino.\n")
            return

        path = []
        cur = dest
        while cur != -1:
            path.append(cur)
            cur = self.parent[cur]
        path.reverse()

        print(f"Camino más corto hacia {self.names[dest]}:")
        print(" -> ".join(self.names[i] for i in path))
        print(f"Distancia total: {self.dist[dest]} m\n")

        path_edges = []
        for i in range(len(path) - 1):
            path_edges.append((path[i], path[i + 1]))

        self.draw(path_edges=path_edges, title_extra=f"(camino a {self.names[dest]})")
        time.sleep(1.5)


names = [
    "Catedral de Guadalajara",
    "Cruce de Juárez y Alcalde",
    "Parque Rojo",
    "Cruce Vallarta y E. Díaz de León",
    "Parque Expiatorio",
    "Los Dos Templos",
    "Leonela Café",
    "Cinépolis Tolsá",
    "Cruce Federalismo–Hidalgo"
]

g = Graph(names)

g.add_edge(0, 1, 200)
g.add_edge(1, 2, 798)
g.add_edge(2, 3, 374)
g.add_edge(3, 4, 203)
g.add_edge(4, 5, 1263)
g.add_edge(5, 1, 349)
g.add_edge(4, 6, 372)
g.add_edge(7, 5, 1470)
g.add_edge(6, 7, 484)
g.add_edge(0, 8, 737)
g.add_edge(2, 8, 254)
g.add_edge(4, 7, 258)

print("Nodos del grafo:")
for i, n in enumerate(names):
    print(f"{i} -> {n}")
print()

g.print_graph()

start = int(input("Selecciona nodo origen (0-8): "))
print()
g.dijkstra(start)

while True:
    dest = int(input("Destino (-1 para salir): "))
    if dest == -1:
        break
    g.print_shortest_path(dest)

plt.ioff()
plt.show()
